Q1: Which registers contain arguments to functions? For example, which register holds 13 in main’s call to printf?
    A: 函数参数的寄存器为a0~a7.printf的13存在寄存器a2中
Q2: Where is the call to function f in the assembly code for main? Where is the call to g? (Hint: the compiler may inline functions.)
    A: 在46行可以看到,编译器进行了函数内联,直接将f(8)+1的值12计算出来了.函数f将函数g内联了.
Q3: At what address is the function printf located?
    A: 由第49和50行可以看出,jalr跳转的地址为0x30+1536=0x630,即函数printf的地址为0x630
Q4: What value is in the register ra just after the jalr to printf in main?
    A: 根据jalr指令的功能, 在刚跳转后ra的值为pc+4=0x34+4=0x38.
Q5: Run the following code.
        unsigned int i = 0x00646c72;
        printf("H%x Wo%s", 57616, &i);
    What is the output?
    The output depends on that fact that the RISC-V is little-endian. If the RISC-V were instead big-endian what would you set i to in order to
    yield the same output? Would you need to change 57616 to a different value?
    A: 输出:HE110 World.若为大端对齐,i需要设置为0x726c6400,不需要改变57616的值. 
Q6: In the following code, what is going to be printed after y=? (note: the answer is not a specific value.) Why does this happen?
        printf("x=%d y=%d", 3);
        A: 根据函数的传参规则,y=后跟的值应该为寄存器a2的值.这种情况发生的原因在于,printf()的格式字符串的数量和不定参数的数量不一致,但函数执行时仍然从
        原本参数应该加载的寄存器取值.按照RISC-V传参规则,第二个不定参数应该被存于寄存器a2,因此在实际输出时也是将a2寄存器的值进行输出.